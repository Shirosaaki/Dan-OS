#include <kernel/drivers/elf.h>
#include <kernel/fs/fat32.h>
#include <kernel/arch/x86_64/vmm.h>
#include <kernel/arch/x86_64/pmm.h>
#include <kernel/sys/kmalloc.h>
#include <kernel/sys/string.h>
#include <kernel/sys/tty.h>
#include <stdint.h>
#include <stddef.h>

#define PT_LOAD 1
#define ELFMAG0 0x7F
#define ELFMAG1 'E'
#define ELFMAG2 'L'
#define ELFMAG3 'F'
#define ELFCLASS64 2
#define ET_EXEC 2
#define ET_DYN 3
#define PAGE_SIZE 4096

static void* local_memcpy(void *dst, const void *src, size_t n) {
    uint8_t *d = (uint8_t *)dst;
    const uint8_t *s = (const uint8_t *)src;
    for (size_t i = 0; i < n; ++i) d[i] = s[i];
    return dst;
}

static inline uint64_t page_round_down(uint64_t v) { return v & ~(PAGE_SIZE - 1); }
static inline uint64_t page_round_up(uint64_t v) { return (v + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1); }

// Helper to read entire file into memory
static uint8_t *load_file_into_memory(const char *path, size_t *out_size) {
    fat32_file_t file;
    if (fat32_open_file(path, &file) != 0) {
        return NULL;
    }
    
    // Get file size by reading FAT entry (rough estimate - just read a bunch)
    uint8_t *buffer = (uint8_t *)kmalloc(65536);  // 64KB buffer
    if (!buffer) return NULL;
    
    int bytes_read = fat32_read_file(&file, buffer, 65536);
    if (bytes_read <= 0) {
        kfree(buffer);
        return NULL;
    }
    
    *out_size = bytes_read;
    return buffer;
}

int elf_load_and_create_address_space(const char *path, char *const argv[], char *const envp[], struct proc *newproc) {
    tty_putstr("[ELF] Loading: ");
    tty_putstr(path);
    tty_putstr("\n");

    if (!path || !newproc) return -1;

    // Load entire file into kernel memory first
    size_t file_size = 0;
    uint8_t *file_data = load_file_into_memory(path, &file_size);
    if (!file_data || file_size < sizeof(Elf64_Ehdr)) {
        tty_putstr("[ELF] Failed to load file\n");
        if (file_data) kfree(file_data);
        return -2;
    }

    Elf64_Ehdr *ehdr = (Elf64_Ehdr *)file_data;

    // Validate ELF
    if (ehdr->e_ident[0] != ELFMAG0 || ehdr->e_ident[1] != ELFMAG1 || 
        ehdr->e_ident[2] != ELFMAG2 || ehdr->e_ident[3] != ELFMAG3) {
        tty_putstr("[ELF] Invalid magic\n");
        kfree(file_data);
        return -3;
    }
    if (ehdr->e_ident[4] != ELFCLASS64) {
        tty_putstr("[ELF] Not 64-bit\n");
        kfree(file_data);
        return -4;
    }

    tty_putstr("[ELF] Entry: ");
    tty_puthex64(ehdr->e_entry);
    tty_putstr(" Type: ");
    tty_putdec(ehdr->e_type);
    tty_putstr("\n");

    // Get kernel CR3
    uint64_t kernel_cr3 = vmm_get_cr3();

    // Clone page table for new process
    uint64_t user_cr3 = vmm_clone_table(kernel_cr3);
    if (!user_cr3) {
        tty_putstr("[ELF] Clone failed\n");
        kfree(file_data);
        return -5;
    }
    newproc->cr3 = user_cr3;

    // Get program headers
    Elf64_Phdr *phdrs = (Elf64_Phdr *)(file_data + ehdr->e_phoff);

    // Process each PT_LOAD segment
    for (unsigned i = 0; i < ehdr->e_phnum; i++) {
        Elf64_Phdr *ph = &phdrs[i];
        if (ph->p_type != PT_LOAD) continue;

        uint64_t seg_va = ph->p_vaddr;
        uint64_t seg_start = page_round_down(seg_va);
        uint64_t seg_end = page_round_up(seg_va + ph->p_memsz);
        uint64_t seg_file_offset = ph->p_offset;
        uint64_t seg_file_size = ph->p_filesz;
        uint64_t seg_mem_size = ph->p_memsz;

        tty_putstr("[ELF] Segment: va=");
        tty_puthex64(seg_va);
        tty_putstr(" filesz=");
        tty_putdec(seg_file_size);
        tty_putstr(" memsz=");
        tty_putdec(seg_mem_size);
        tty_putstr("\n");

        // Allocate and map pages
        uint8_t **page_ptrs = (uint8_t **)kmalloc(sizeof(uint8_t *) * 512);
        int page_count = 0;

        for (uint64_t va = seg_start; va < seg_end; va += PAGE_SIZE) {
            void *phys_page = pmm_alloc_page();
            if (!phys_page) {
                tty_putstr("[ELF] PMM alloc failed\n");
                kfree(file_data);
                kfree(page_ptrs);
                return -6;
            }

            // Map in user page table (with WRITE for now to copy data)
            uint64_t pa = (uint64_t)(uintptr_t)phys_page;
            if (vmm_map_page_in_table(user_cr3, va, pa, 0x1 | 0x2 | 0x4) != 0) {
                tty_putstr("[ELF] Map page failed\n");
                kfree(file_data);
                kfree(page_ptrs);
                return -7;
            }

            // Store pointer to this page for data copying
            page_ptrs[page_count] = (uint8_t *)phys_page;
            page_count++;
        }

        // Copy data to pages
        if (seg_file_size > 0) {
            uint8_t *file_ptr = file_data + seg_file_offset;
            uint64_t va_offset = seg_va - seg_start;  // offset into first page
            uint64_t bytes_copied = 0;

            for (int p = 0; p < page_count && bytes_copied < seg_file_size; p++) {
                uint8_t *page_ptr = page_ptrs[p];
                uint64_t offset_in_page = (p == 0) ? va_offset : 0;
                uint64_t to_copy = PAGE_SIZE - offset_in_page;
                if (bytes_copied + to_copy > seg_file_size) {
                    to_copy = seg_file_size - bytes_copied;
                }

                local_memcpy(page_ptr + offset_in_page, file_ptr + bytes_copied, to_copy);
                bytes_copied += to_copy;

                tty_putstr("[ELF] Copied ");
                tty_putdec(to_copy);
                tty_putstr(" bytes to page ");
                tty_putdec(p);
                tty_putstr(" at PA=");
                tty_puthex64((uint64_t)(uintptr_t)page_ptr);
                tty_putstr("\n");
            }
        }

        kfree(page_ptrs);
    }

    kfree(file_data);
    
    // Set entry point
    newproc->entry = ehdr->e_entry;
    
    tty_putstr("[ELF] Entry point set to ");
    tty_puthex64(newproc->entry);
    tty_putstr("\n");

    // Setup user stack
    void *stack_page = pmm_alloc_page();
    if (!stack_page) {
        tty_putstr("[ELF] Stack alloc failed\n");
        return -8;
    }

    // Zero stack
    memset_k(stack_page, 0, PAGE_SIZE);

    // Map stack
    uint64_t stack_va = 0x7FFFFFFFF000ULL;
    uint64_t stack_pa = (uint64_t)(uintptr_t)stack_page;
    
    if (vmm_map_page_in_table(user_cr3, stack_va, stack_pa, 0x1 | 0x2 | 0x4) != 0) {
        tty_putstr("[ELF] Stack map failed\n");
        return -9;
    }

    // Set RSP
    uint64_t stack_top = stack_va + PAGE_SIZE;
    newproc->user_rsp = (stack_top - 16) & ~0xFULL;

    tty_putstr("[ELF] Load complete: entry=");
    tty_puthex64(newproc->entry);
    tty_putstr(" rsp=");
    tty_puthex64(newproc->user_rsp);
    tty_putstr("\n");

    return 0;
}
